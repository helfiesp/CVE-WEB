import sqlite3
from datetime import datetime
from misc_scripts import secrets
import requests
import os
import json
import csv
import time

import urllib3
urllib3.disable_warnings()


db_path = "/var/csirt/source/CVE-WEB/db.sqlite3"
api_key = os.environ["HAVEIBEENPWNED_API_KEY"]

headers = {
    "hibp-api-key": api_key,
    "Content-Type": "application/json"
}


def LoadProxy():
    os.environ["http_proxy"] = "http://{}:{}@inetproxy.oslofelles.oslo.kommune.no:3128".format(os.environ["CSIRT_LDAPUSER"], os.environ["CSIRT_LDAPPASSWORD"])
    os.environ["https_proxy"] = "http://{}:{}@inetproxy.oslofelles.oslo.kommune.no:3128".format(os.environ["CSIRT_LDAPUSER"], os.environ["CSIRT_LDAPPASSWORD"])

def DisableProxy():
    os.environ.pop("http_proxy", None)
    os.environ.pop("https_proxy", None)


def convert_csv_to_json(csv_data):
    json_data = []
    csv_reader = csv.DictReader(csv_data.splitlines())
    for row in csv_reader:
        json_data.append(row)
    return json_data

def FetchBreachedSitesInfo(breached_site):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('SELECT name, breach_date, description, data_classes FROM alerts_haveibeenpwnedbreaches WHERE name=?', (breached_site,))
    result = cursor.fetchone()
    
    if result:
        data = {
            'breached_site': result[0],
            'breach_date': result[1],
            'description': result[2],
            'data_classes': json.loads(result[3])
        }
        return data
    else:
        return {}

def FetchBreachedDomains():
    LoadProxy()
    domains_list = "/var/csirt/source/CVE-WEB/static/hibp_domains.txt"
    with open(domains_list) as file:
        domains = [line.rstrip() for line in file]
    
    for domain in domains:
        api_endpoint = "https://haveibeenpwned.com/api/v3/breacheddomain/{}".format(domain)
        response = requests.get(api_endpoint, headers=headers, verify=False)
        if response.status_code == 200:
            print("Fetched data for: {}".format(domain))
            breaches_data = response.json()
            
            # Connect to SQLite database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            for user, breached_sites in breaches_data.items():
                email_address = "{}@{}".format(user, domain)
                
                # Fetch breached data for each breached site
                breached_data = []
                for breached_site in breached_sites:
                    result = FetchBreachedSitesInfo(breached_site)
                    if result:
                        breached_data.append(result)
                
                # Check if the combination of email address and breached sites already exists
                cursor.execute('''
                    SELECT COUNT(*) FROM alerts_haveibeenpwnedbreachedaccounts
                    WHERE email_address = ? AND breached_sites = ?
                ''', (email_address, str(breached_sites)))
                
                existing_record_count = cursor.fetchone()[0]
                
                if existing_record_count == 0:
                    # Insert the record if it doesn't already exist
                    cursor.execute('''
                        INSERT INTO alerts_haveibeenpwnedbreachedaccounts (email_address, breached_sites, breached_data)
                        VALUES (?, ?, ?)
                    ''', (email_address, str(breached_sites), json.dumps(breached_data)))
                
            conn.commit()
            conn.close()
        else:
            print(f"Failed to fetch data: {response.status_code}")

    DisableProxy()


def FetchBreachInfo():
    LoadProxy()
    api_endpoint = "https://haveibeenpwned.com/api/v3/breaches"
    response = requests.get(api_endpoint, headers=headers, verify=False)
    DisableProxy()

    if response.status_code == 200:
        breaches_data = response.json()

        # Connect to SQLite database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Iterate through each item in the response
        for item in breaches_data:
            # Prepare data for insertion
            name = item.get('Name', '')
            title = item.get('Title', '')
            domain = item.get('Domain', '')
            breach_date = item.get('BreachDate', '')
            added_date = datetime.strptime(item['AddedDate'], '%Y-%m-%dT%H:%M:%SZ') if 'AddedDate' in item else None
            modified_date = datetime.strptime(item['ModifiedDate'], '%Y-%m-%dT%H:%M:%SZ') if 'ModifiedDate' in item else None
            pwn_count = item.get('PwnCount', 0)
            description = item.get('Description', '')
            logo_path = item.get('LogoPath', '')
            data_classes = json.dumps(item.get('DataClasses', []))
            is_verified = item.get('IsVerified', False)
            is_fabricated = item.get('IsFabricated', False)
            is_sensitive = item.get('IsSensitive', False)
            is_retired = item.get('IsRetired', False)
            is_spam_list = item.get('IsSpamList', False)
            is_malware = item.get('IsMalware', False)
            is_subscription_free = item.get('IsSubscriptionFree', False)

            # Check if the breach already exists in the database
            cursor.execute('''
                SELECT COUNT(*) FROM alerts_haveibeenpwnedbreaches
                WHERE name = ? AND domain = ? AND breach_date = ?
            ''', (name, domain, breach_date))

            existing_record_count = cursor.fetchone()[0]

            if existing_record_count == 0:
                print("Adding: {}".format(name))
                # Insert data into the database if it doesn't already exist
                cursor.execute('''
                    INSERT INTO alerts_haveibeenpwnedbreaches (name, title, domain, breach_date, added_date, 
                    modified_date, pwn_count, description, logo_path, data_classes, is_verified, 
                    is_fabricated, is_sensitive, is_retired, is_spam_list, is_malware, is_subscription_free)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (name, title, domain, breach_date, added_date, modified_date, pwn_count,
                    description, logo_path, data_classes, is_verified, is_fabricated, 
                    is_sensitive, is_retired, is_spam_list, is_malware, is_subscription_free))
                conn.commit()
                conn.close()

        # Commit changes and close the connection
        conn.commit()
        conn.close()
    else:
        print(f"Failed to fetch data: {response.status_code}")


if __name__ == "__main__":
    FetchBreachInfo()