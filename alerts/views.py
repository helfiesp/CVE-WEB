from django.shortcuts import render
from django.http import HttpResponse, HttpRequest
from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required, user_passes_test
from django.core.files.storage import FileSystemStorage
import os
from django.contrib.auth.models import Group
from datetime import datetime
import scripts.get_cves as get_cves
import scripts.shodan_filter as shodan_filter
from .models import CVEScans,ShodanResults,UnlistedCVEs,QualysResults,PasswordSpray,OKDomains,ADUsers, QualysComments
from .forms import OKDomainsForm
import scripts.send_alert_email as alert_email
import scripts.shodan_ as shodan
import scripts.soc_scripts as soc_scripts
from django.shortcuts import render
from django.conf import settings
from django.core.files.storage import FileSystemStorage
import requests
import subprocess
import json
import logging
import time
import csv
import sys
import ldap


def is_member_of_group(group_name):
    def check(user):
        return user.is_authenticated and user.groups.filter(name=group_name).exists()
    return check

@user_passes_test(lambda u: u.groups.filter(name='CSIRT').exists(), login_url='qualys')
def index(request):
    found_cves = get_cves.daily_cve()
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Siste døgn', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def cve_weekly(request):
    found_cves = get_cves.weekly_cve()
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Siste 7 dager', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def cve_monthly(request):
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    found_cves = get_cves.monthly_cve()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Denne måneden', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def cve_all(request):
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    found_cves = get_cves.all_cve()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Denne måneden', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)


def GetCVEStatistics(cve_list):
    severity = {'Kritisk':0,'Høy':0,'Medium':0,'Lav':0,'N/A':0}
    cve_count = len(cve_list)
    for cve in cve_list:
        if cve["cvss_score"] == "N/A":
            severity["N/A"] +=1
        elif cve["cvss_score"] >= 9:
            severity["Kritisk"] += 1
        elif cve["cvss_score"] >= 7.5:
            severity["Høy"] += 1
        elif cve["cvss_score"] >= 5:
            severity["Medium"] += 1
        else:
            severity["Lav"] += 1
    return cve_count, severity

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def send_alert(request):
    if request.method == "POST":
        selected_cves = request.POST.getlist("send_alert")
        if len(selected_cves) == 0:
            context = {'AlertMessage':'Du må velge CVEer fra CVE listen for å kunne sende en varsling.'}
        else:
            context = {'Selected_CVEs':get_cves.single_cve(selected_cves)}
    return render(request,'send_alert.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def send_alert_email(request):
    if request.method == "POST":
        table = request.POST.get("CVE_Table")
        receiver = request.POST.get("alert_receiver")
        cc = request.POST.get("alert_cc")
        alert_text = request.POST.get("alert_text")
        CVE = request.POST.getlist("CVEs")
        context = {'receiver':receiver, 'cc':cc, 'description':alert_text, 'CVES':CVE}
        alert_email.main(context)
        found_cves = get_cves.daily_cve()
        scan_info = str(*CVEScans.objects.filter(scan_type="daily").values('scan_end').last().values())
        context = {'message':'<b>Sucess</b>: E-mail sent to: {}'.format(receiver),'CVE_list':found_cves, 'CVE_Count':len(found_cves), 'Query':'Realtime CVE', 'Last_scan':scan_info}
        return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def GoogleNewsScraper(request):
    context = {'UnlistedCVEs':UnlistedCVEs.objects.values()}
    return render(request,'new_cve_scraper.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def Shodan(request):
    shodan_info = shodan.GetResults(0)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsCritical(request):
    shodan_info = shodan.GetResults(5)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsHigh(request):
    shodan_info = shodan.GetResults(4)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsCriticalHigh(request):
    shodan_info = shodan.GetResults(45)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsAll(request):
    shodan_info = shodan.GetResults(1)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def update_shodan_entry(request):
    if request.method == "POST":
        comments = request.POST.getlist("comment")
        ids = request.POST.getlist("entry_id")
        for x,y in zip(ids, comments):
            entry = ShodanResults.objects.get(id=x)
            entry.entry_comments = y
            entry.save(update_fields=['entry_comments'])
    shodan_info = shodan.GetResults(0)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)



@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def SOC(request):
    context = {'':''}
    return render(request,'soc.html', context)


@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def SOC_Scan_Url(request):
    if request.method == "POST":
        url = request.POST.get("scan_url_entry")
        context = {'URLScan':soc_scripts.URLScanIO(url)}
        return render(request,'soc.html', context)

def GetQualysStats(qualys_results, current_query):
    severity = {'5':0,'4':0,'3':0,'2':0,'1':0}
    internet_exposed = 0
    internet_exposed_ips = []
    for entry in qualys_results:
        severity["{}".format(entry["severity"])] += 1
        if entry["internet_exposed"] == "1":
            internet_exposed += 1
            if entry["hostname"] not in internet_exposed_ips:
                internet_exposed_ips.append(entry["hostname"])
    qualys_stats = {'Timestamp':GetQualysLastEntry(),'Current query':current_query, 'Amount of entries':len(qualys_results), 'Severity':severity, 'Entries with internet exposed':internet_exposed,'Unique internet exposed assets': len(internet_exposed_ips)}
    return qualys_stats


def GetQualysLastEntry():
    # Fetches the latest entry from thr qualys database.
    # This is to ensure that the newest data is shown.
    last_entry = QualysResults.objects.values().last()["scan_time"]
    return last_entry

def GetCisaVulns():
    # Fetches the CISA known exploited vulnerabilities from a local JSON document.
    # It is not being fetched directly from the CISA website as there are some issues with the proxy.
    cve_list = []
    cisa_file = json.load(open("/var/csirt/source/CVE-WEB/uploads/data/cisa_known_exploited.json"))
    for entry in cisa_file["vulnerabilities"]:
        if entry["cveID"] not in cve_list:
            cve_list.append(entry["cveID"])
    return cve_list

def UpdateQualysCISAField(entry_id, entry_value):
    # Updates the known_exploited field in the QualysDB
    entry = QualysResults.objects.get(id=entry_id)
    entry.known_exploited = entry_value
    entry.save()


@login_required
def Qualys(request):
    last_entry = GetQualysLastEntry()
    context = {'filters':{'dataset':GroupChecker(request), 'last_entry':last_entry}}
    return render(request,'qualys.html', context)


def GroupChecker(request):
    # Checks which group the user is part of to ensure that the correct data is shown to each user.
    groups = {
    "CSIRT":["all"],
    "ITAS":["OK-ITAS"],
    "ACOS_UKE": ["OK-Acos - Standard tjeneste"]
    }

    dataset = ""
    for group in groups:
        group_check = is_member_of_group(group)
        if group_check(request.user):
            dataset = groups[group]
            break 
    return dataset 

def QualysSearchQuery(filters):
   # Create a dictionary to map filter types to fields
    filter_mapping = {
        "hostname": "hostname",
        "bss": "bss",
        "system": "system",
        "cve": "cve",
        "vulnerability_name":"title",
        "filepath":"filepath",
        "internal_ip":"ip",
        "external_ip":"internet_exposed",
        "comments":"comments"
    }
    # Construct the base query set
    base_query = QualysResults.objects.filter(
        scan_time=GetQualysLastEntry()
    )

    # Apply filters
    if filters["dataset"] != ["all"]:
        base_query = base_query.filter(bs__in=filters["dataset"])
    if filters["internet_exposed"]:
        base_query = base_query.exclude(internet_exposed__contains="e")
    if filters["critical_vulns"]:
        base_query = base_query.filter(severity="5")
    if filters["known_exploited"]:
        base_query = base_query.filter(known_exploited="1")

    # Add the search field filter
    search_field = filter_mapping[filters["search_type"]]
    search_value = filters["vuln_search"]
    search_query = {f"{search_field}__contains": search_value}
    base_query = base_query.filter(**search_query)

    # Get the query results
    qualys_server_results = base_query.values()
    return QualysDataFilter(qualys_server_results)

def QualysOverview(qualys_data, filters):
    grouped_data = {}
    for entry in qualys_data:
        title = entry['title']
        if title in grouped_data:
            grouped_data[title]['count'] += 1
        else:
            grouped_data[title] = {'title': title, 'count': 1}

        if 'severity' not in grouped_data[title]:
            grouped_data[title]['severity'] = entry['severity']

        if 'cve' not in grouped_data[title]:
            grouped_data[title]['cve'] = entry['cve']

        if 'hostnames' not in grouped_data[title]:
            grouped_data[title]['hostnames'] = []
        grouped_data[title]['hostnames'].append(entry['hostname'])

        # Fetch comments from QualysComments table based on title
        comments = QualysComments.objects.filter(title=title, filters=filters)
        comment_list = [comment.comment for comment in comments]
        grouped_data[title]['comments'] = ", ".join(comment_list)

    result = sorted(grouped_data.values(), key=lambda x: x['count'], reverse=True)
    return result



def UpdateQualysCommentField(title, hostname, comment):
    # Updates the known_exploited field in the QualysDB
    entry = QualysResults.objects.get(title=title, hostname=hostname)
    entry.comments = comment
    entry.save()


def UpdateQualysCommentsDB(title, filters, servers, comment):
    # Updates the known_exploited field in the QualysDB
    entry, created = QualysComments.objects.get_or_create(title=title, filters=filters, servers=servers)
    entry.comment = comment
    entry.save()


def UpdateQualysComments(request):
    if request.method == 'POST':
        search_filters = dict(eval(request.POST.get("filters")))
        hostnames = request.POST.getlist("hostnames")
        servers = []
        for entry in hostnames:
            servers.append(entry.split("-|-")[1])
        entries = []
        for key, value in request.POST.items():
            if key.startswith("comment"):
                comment_dict = {"title":key.replace("comment-", ""), "comment":value}
                entries.append(comment_dict.copy())
                UpdateQualysCommentsDB(comment_dict["title"], search_filters, str(servers), value)
        for entry in hostnames:
            title = entry.split("-|-")[0]
            hostname = entry.split("-|-")[1]
            for entry in entries:
                if entry["title"] == title:
                    UpdateQualysCommentField(title, hostname, entry["comment"])
    return QualysSearch(request, search_filters)




def QualysDataFilter(qualys_data):
    checklist = []
    for entry in qualys_data:
        if entry["id"] not in checklist:
            checklist.append([entry["id"], entry])
    qualys_data_filtered = []
    for entry in checklist:
        if entry[1]["systemmanager"]:
            entry[1]["systemmanager"] = entry[1]["systemmanager"].translate(str.maketrans('', '', "[]'"))
        if "e" in entry[1]["internet_exposed"]:
            entry[1]["internet_exposed"] = "N/A"
        if entry[1]["last_fixed"] == "NaT":
            entry[1]["last_fixed"] = "N/A"
        if entry[1]["cve"] == "nan":
            entry[1]["cve"] = "N/A"
        qualys_data_filtered.append(entry[1])
    return qualys_data_filtered

def QualysGetStats(qualys_results):
    pass

def QualysGetFilters(request, dataset):
    last_entry = GetQualysLastEntry()
    filters = {
        "last_entry":last_entry,
        "dataset": dataset,
        "filepath": request.POST.get("filepath_checkbox"), 
        "internet_exposed":request.POST.get("internetex_checkbox"),
        "overview":request.POST.get("overview_checkbox"),
        "critical_vulns": request.POST.get("critical_vulns_checkbox"), 
        "all_entries":request.POST.get("all_checkbox"), 
        "known_exploited":request.POST.get("knownex_checkbox"),
        "vuln_search":request.POST.get("vuln_search"),
        "search_type":request.POST.get("search_type"),
        "systeminfo":request.POST.get("systeminfo_checkbox"),
        "business_service":request.POST.get("business_service_checkbox"),
        "comments":request.POST.get("comments_checkbox"),
    }
    return filters

@login_required
def QualysSearch(request, filters=None):
    if request.method == "POST":
        if not filters:
            filters = QualysGetFilters(request, GroupChecker(request))
        qualys_results = QualysSearchQuery(filters)        
        if filters["overview"]:
            context = {'QualysResults':qualys_results, "filters":filters, "overview_table":QualysOverview(qualys_results, filters)}
        else:
            context = {'QualysResults':qualys_results, "filters":filters}
        return render(request,'qualys.html', context)
    else:
        message = "Du må velge et filter for å vise resultater..."
        context = {'message':message}
        return render(request,'qualys.html', context)


@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ExposedPasswords(request):
    data = PasswordSpray.objects.values()
    for entry in data:
        for item in list(eval(entry["userinfo"])):
            if entry["user"] in str(item):
                for x in item:
                    if type(x) == dict:
                        entry["groups"] = x["memberOf"]
    context = {'data':data}
    return render(request,'exposed_passwords.html', context)

def VulnerabilityUpload(request):
    if request.method == 'POST':
        file = request.FILES['file']
        filename = file.name
        upload_path = '/var/csirt/source/CVE-WEB/uploads/qualys_vulns/'

        # Get the selected vulnerability type from the dropdown menu
        vulnerability_type = request.POST.get('vulnerability_type')

        # Check if the selected vulnerability type is Qualys or Defender and set the filename accordingly
        if vulnerability_type == 'Qualys':
            new_filename = 'QualysVulnerabilities.xlsx'
            script_path = '/var/csirt/source/CVE-WEB/scripts/updatequalys.sh'
        elif vulnerability_type == 'Defender':
            new_filename = 'DefenderVulnerabilities.xlsx'
            script_path = '/var/csirt/source/CVE-WEB/scripts/updatedefender.sh'
        else:
            # Return an error message if the selected vulnerability type is invalid
            context = {'filename': '', 'upload_result': 'error', 'output': '', 'error': 'Invalid request'}
            return render(request, 'qualys_upload.html', context)

        file_path = os.path.join(upload_path, new_filename)

        # Remove the existing "Vulnerabilities.xlsx" file if it exists
        existing_file_path = os.path.join(upload_path, new_filename)
        if os.path.isfile(existing_file_path):
            os.remove(existing_file_path)

        # Save the uploaded file with the appropriate filename
        with open(file_path, 'wb') as f:
            for chunk in file.chunks():
                f.write(chunk)

        # Run the appropriate script based on the selected vulnerability type
        process = subprocess.Popen(['/bin/bash', script_path, file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate()

        # Decode the output and error from bytes to string
        output = output.decode()
        error = error.decode()

        # Render the qualys_upload.html template with the upload result and script output
        context = {'filename': new_filename, 'upload_result': 'success', 'output': output, 'error': error}
        return render(request, 'qualys_upload.html', context)

    return render(request, 'qualys_upload.html')

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def AttackSurfaceDomains(request):
    okdomains = OKDomains.objects.all()
    context = {'okdomains': okdomains}
    return render(request,'attack_surface_domains.html', context)

def InsertOKDomain(request):
    blacklist = ['powerapps']
    if request.method == 'POST':
        form = OKDomainsForm(request.POST)
        if form.is_valid():
            # Extract form data and create a new OKDomains object
            domain = form.cleaned_data['domain']

            # Check if domain is in blacklist 
            for entry in blacklist:
                if entry in str(domain):
                    context = {'uploadmessage': 'Error: Domain is blacklisted'}
                    return render(request, 'domains_upload.html', context)

            okdomains, created = OKDomains.objects.get_or_create(domain=domain)

            if created:
                # New domain, set all fields from form data
                okdomains.registrar = form.cleaned_data['registrar']
                okdomains.server = form.cleaned_data['server']
                okdomains.system = form.cleaned_data['system']
                okdomains.system_owner = form.cleaned_data['system_owner']
                okdomains.comments = form.cleaned_data['comments']
                okdomains.changes_since_last = "Initial upload"
            else:
                # Existing domain, update fields only if not empty
                if form.cleaned_data['registrar']:
                    okdomains.registrar = form.cleaned_data['registrar']
                if form.cleaned_data['server']:
                    okdomains.server = form.cleaned_data['server']
                if form.cleaned_data['system']:
                    okdomains.system = form.cleaned_data['system']
                if form.cleaned_data['system_owner']:
                    okdomains.system_owner = form.cleaned_data['system_owner']
                if form.cleaned_data['comments']:
                    okdomains.comments = form.cleaned_data['comments']
                okdomains.changes_since_last = "Updated from upload"

            okdomains.save()
            context = {'uploadmessage': 'Upload completed'}
            return render(request, 'domains_upload.html', context)

        elif request.method == 'POST' and request.FILES:
            # Read CSV file and update database
            try:
                file = request.FILES['file']
                decoded_file = file.read().decode('ISO-8859-1').splitlines()
                reader = csv.DictReader(decoded_file)

                domains = []
                for row in reader:
                    domain = row.get('domain')
                    domains.append(domain)

                # Get all existing domains from database
                existing_domains = OKDomains.objects.filter(domain__in=domains)

                # Update the existing domains
                for existing_domain in existing_domains:
                    # Update fields only if not empty
                    if row.get('registrar'):
                        existing_domain.registrar = row.get('registrar')
                    if row.get('server'):
                        existing_domain.server = row.get('server')
                    if row.get('system'):
                        existing_domain.system = row.get('system')
                    if row.get('system_owner'):
                        existing_domain.system_owner = row.get('system_owner')
                    if row.get('comments'):
                        existing_domain.comments = row.get('comments')
                    existing_domain.changes_since_last = "Updated from upload"
                    existing_domain.save()

                existing_db_domains = []
                for entry in existing_domains.values():
                    existing_db_domains.append(entry["domain"])
                reader = csv.DictReader(decoded_file)
                for row in reader:
                    domain = row.get('domain')
                    if domain not in existing_db_domains:
                        for entry in blacklist:
                            if entry not in str(domain):
                                new_domain = OKDomains(
                                    domain=domain,
                                    registrar=row.get('registrar'),
                                    server=row.get('server'),
                                    system=row.get('system'),
                                    system_owner=row.get('system_owner'),
                                    comments=row.get('comments'),
                                    changes_since_last="Added from upload"
                                )
                                new_domain.save()

                context = {'uploadmessage': 'Upload completed'}
                return render(request, 'domains_upload.html', context)

            except Exception as e:
                context = {'uploadmessage': 'Error during file upload: {}'.format(e)}
                return render(request, 'domains_upload.html', context)
    else:
        form = OKDomainsForm()
        context = {'form': form}
        return render(request, 'domains_upload.html', context)

def ActiveDirectory(request):
    return render(request, 'active_directory.html')

def LDAPInit():
    ldap_server  = 'ldaps://ldaps.oslofelles.oslo.kommune.no:636'
    username  = os.environ["CSIRT_LDAPUSER"]
    password  = os.environ["CSIRT_LDAPPASSWORD"]
    base_dn =  "DC=oslofelles,DC=oslo,DC=kommune,DC=no"
    ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_NEVER)
    ldap.set_option(ldap.OPT_PROTOCOL_VERSION, 3)
    ldap_conn = ldap.initialize(ldap_server)
    ldap_conn.set_option(ldap.OPT_REFERRALS, 0)
    return ldap_conn


