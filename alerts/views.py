from django.shortcuts import render
from django.http import HttpResponse, HttpRequest
from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required, user_passes_test
from django.core.files.storage import FileSystemStorage
import os
from django.contrib.auth.models import Group
from datetime import datetime
import scripts.get_cves as get_cves
import scripts.shodan_filter as shodan_filter
from .models import CVEScans,ShodanResults,UnlistedCVEs,QualysResults,PasswordSpray,OKDomains
from .forms import OKDomainsForm
import scripts.send_alert_email as alert_email
import scripts.shodan_ as shodan
import scripts.soc_scripts as soc_scripts
from django.shortcuts import render
from django.conf import settings
from django.core.files.storage import FileSystemStorage
import requests
import subprocess
import json
import logging
import time
import csv
import sys


def is_member_of_group(group_name):
    def check(user):
        return user.is_authenticated and user.groups.filter(name=group_name).exists()
    return check

@user_passes_test(lambda u: u.groups.filter(name='CSIRT').exists(), login_url='qualys')
def index(request):
    found_cves = get_cves.daily_cve()
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Siste døgn', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def cve_weekly(request):
    found_cves = get_cves.weekly_cve()
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Siste 7 dager', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def cve_monthly(request):
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    found_cves = get_cves.monthly_cve()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Denne måneden', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def cve_all(request):
    found_news = get_cves.daily_news()
    UnlistedCVEs = get_cves.unlisted_cves()
    found_cves = get_cves.all_cve()
    cve_stats = GetCVEStatistics(found_cves)
    context = {'CVE_list':found_cves, 'CVECount':cve_stats[0], 'CVEStats':cve_stats[1], 'CVEQuery':'Denne måneden', 'DailyNews':found_news, 'UnlistedCVEs':UnlistedCVEs}
    return render(request,'index.html', context)


def GetCVEStatistics(cve_list):
    severity = {'Kritisk':0,'Høy':0,'Medium':0,'Lav':0,'N/A':0}
    cve_count = len(cve_list)
    for cve in cve_list:
        if cve["cvss_score"] == "N/A":
            severity["N/A"] +=1
        elif cve["cvss_score"] >= 9:
            severity["Kritisk"] += 1
        elif cve["cvss_score"] >= 7.5:
            severity["Høy"] += 1
        elif cve["cvss_score"] >= 5:
            severity["Medium"] += 1
        else:
            severity["Lav"] += 1
    return cve_count, severity

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def send_alert(request):
    if request.method == "POST":
        selected_cves = request.POST.getlist("send_alert")
        if len(selected_cves) == 0:
            context = {'AlertMessage':'Du må velge CVEer fra CVE listen for å kunne sende en varsling.'}
        else:
            context = {'Selected_CVEs':get_cves.single_cve(selected_cves)}
    return render(request,'send_alert.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def send_alert_email(request):
    if request.method == "POST":
        table = request.POST.get("CVE_Table")
        receiver = request.POST.get("alert_receiver")
        cc = request.POST.get("alert_cc")
        alert_text = request.POST.get("alert_text")
        CVE = request.POST.getlist("CVEs")
        context = {'receiver':receiver, 'cc':cc, 'description':alert_text, 'CVES':CVE}
        alert_email.main(context)
        found_cves = get_cves.daily_cve()
        scan_info = str(*CVEScans.objects.filter(scan_type="daily").values('scan_end').last().values())
        context = {'message':'<b>Sucess</b>: E-mail sent to: {}'.format(receiver),'CVE_list':found_cves, 'CVE_Count':len(found_cves), 'Query':'Realtime CVE', 'Last_scan':scan_info}
        return render(request,'index.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def GoogleNewsScraper(request):
    context = {'UnlistedCVEs':UnlistedCVEs.objects.values()}
    return render(request,'new_cve_scraper.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def Shodan(request):
    shodan_info = shodan.GetResults(0)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsCritical(request):
    shodan_info = shodan.GetResults(5)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsHigh(request):
    shodan_info = shodan.GetResults(4)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsCriticalHigh(request):
    shodan_info = shodan.GetResults(45)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ShodanVulnsAll(request):
    shodan_info = shodan.GetResults(1)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def update_shodan_entry(request):
    if request.method == "POST":
        comments = request.POST.getlist("comment")
        ids = request.POST.getlist("entry_id")
        for x,y in zip(ids, comments):
            entry = ShodanResults.objects.get(id=x)
            entry.entry_comments = y
            entry.save(update_fields=['entry_comments'])
    shodan_info = shodan.GetResults(0)
    context = {'ShodanResults':shodan_info[0], 'Shodan_Stats':shodan_info[1], 'ShodanScans':shodan_info[2], 'Vulns':shodan_info[3]}
    return render(request,'shodan.html', context)



@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def SOC(request):
    context = {'':''}
    return render(request,'soc.html', context)


@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def SOC_Scan_Url(request):
    if request.method == "POST":
        url = request.POST.get("scan_url_entry")
        context = {'URLScan':soc_scripts.URLScanIO(url)}
        return render(request,'soc.html', context)

def GetQualysStats(qualys_results, current_query):
    severity = {'5':0,'4':0,'3':0,'2':0,'1':0}
    internet_exposed = 0
    internet_exposed_ips = []
    for entry in qualys_results:
        severity["{}".format(entry["severity"])] += 1
        if entry["internet_exposed"] == "1":
            internet_exposed += 1
            if entry["hostname"] not in internet_exposed_ips:
                internet_exposed_ips.append(entry["hostname"])
    qualys_stats = {'Timestamp':GetQualysLastEntry(),'Current query':current_query, 'Amount of entries':len(qualys_results), 'Severity':severity, 'Entries with internet exposed':internet_exposed,'Unique internet exposed assets': len(internet_exposed_ips)}
    return qualys_stats


def GetQualysLastEntry():
    last_entry = QualysResults.objects.values().last()["scan_time"]
    return last_entry

def GetCisaVulns():
    cve_list = []
    cisa_file = json.load(open("/var/csirt/source/CVE-WEB/uploads/data/cisa_known_exploited.json"))
    for entry in cisa_file["vulnerabilities"]:
        if entry["cveID"] not in cve_list:
            cve_list.append(entry["cveID"])
    return cve_list

def UpdateQualysCISAField(entry_id, entry_value):
    # Updates the known_exploited field in the QualysDB
    entry = QualysResults.objects.get(id=entry_id)
    entry.known_exploited = entry_value
    entry.save()


@login_required
def Qualys(request):
    last_entry = GetQualysLastEntry()
    group_check = is_member_of_group('CSIRT')
    if group_check(request.user):
        dataset = "all"
    else:
        group_check = is_member_of_group('ITAS')
        if group_check(request.user):
            dataset = "ITAS"
    context = {'filters':{'dataset':dataset, 'last_entry':last_entry}}
    return render(request,'qualys.html', context)


def QualysSearchQuery(filters):
   # Create a dictionary to map filter types to fields
    filter_mapping = {
        "hostname": "hostname",
        "bss": "bss",
        "system": "system",
        "cve": "cve",
        "vulnerability_name":"title",
        "filepath":"filepath",
        "external_ip":"internet_exposed"
    }
    print(filters["dataset"])
    # Construct the base query set
    base_query = QualysResults.objects.filter(
        scan_time=GetQualysLastEntry()
    )

    # Apply filters
    if filters["dataset"] != "all":
        base_query = base_query.filter(bs__contains=filters["dataset"])
    if filters["internet_exposed"]:
        base_query = base_query.exclude(internet_exposed__contains="e")
    if filters["critical_vulns"]:
        base_query = base_query.filter(severity="5")
    if filters["known_exploited"]:
        base_query = base_query.filter(known_exploited="1")

    # Add the search field filter
    search_field = filter_mapping[filters["search_type"]]
    search_value = filters["vuln_search"]
    search_query = {f"{search_field}__contains": search_value}
    base_query = base_query.filter(**search_query)

    # Get the query results
    qualys_server_results = base_query.values()
    return QualysDataFilter(qualys_server_results)


def QualysDataFilter(qualys_data):
    checklist = []
    for entry in qualys_data:
        if entry["id"] not in checklist:
            checklist.append([entry["id"], entry])
    qualys_data_filtered = []
    for entry in checklist:
        if entry[1]["systemmanager"]:
            entry[1]["systemmanager"] = entry[1]["systemmanager"].translate(str.maketrans('', '', "[]'"))
        if "e" in entry[1]["internet_exposed"]:
            entry[1]["internet_exposed"] = "N/A"
        if entry[1]["last_fixed"] == "NaT":
            entry[1]["last_fixed"] = "N/A"
        if entry[1]["cve"] == "nan":
            entry[1]["cve"] = "N/A"
        qualys_data_filtered.append(entry[1])
    return qualys_data_filtered

def QualysGetFilters(request, dataset):
    last_entry = GetQualysLastEntry()
    filters = {
        "last_entry":last_entry,
        "dataset": dataset,
        "filepath": request.POST.get("filepath_checkbox"), 
        "internet_exposed":request.POST.get("internetex_checkbox"),
        "critical_vulns": request.POST.get("critical_vulns_checkbox"), 
        "all_entries":request.POST.get("all_checkbox"), 
        "known_exploited":request.POST.get("knownex_checkbox"),
        "vuln_search":request.POST.get("vuln_search"),
        "search_type":request.POST.get("search_type"),
        "systeminfo":request.POST.get("systeminfo_checkbox"),
        "business_service":request.POST.get("business_service_checkbox"),
    }
    return filters

@login_required
def QualysSearch(request):
    group_check = is_member_of_group('CSIRT')
    if group_check(request.user):
        dataset = "all"
    else:
        group_check = is_member_of_group('ITAS')
        if group_check(request.user):
            dataset = "ITAS"
        else:
            return HttpResponse("Unauthorized access", status=401)

    if request.method == "POST":
        filters = QualysGetFilters(request, dataset)
        context = {'QualysResults':QualysSearchQuery(filters), "filters":filters}
        return render(request,'qualys.html', context)
    else:
        message = "Du må velge et filter for å vise resultater..."
        context = {'message':message}
        return render(request,'qualys.html', context)

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def ExposedPasswords(request):
    data = PasswordSpray.objects.values()
    for entry in data:
        for item in list(eval(entry["userinfo"])):
            if entry["user"] in str(item):
                for x in item:
                    if type(x) == dict:
                        entry["groups"] = x["memberOf"]
    context = {'data':data}
    return render(request,'exposed_passwords.html', context)

def VulnerabilityUpload(request):
    if request.method == 'POST':
        file = request.FILES['file']
        filename = file.name
        upload_path = '/var/csirt/source/CVE-WEB/uploads/qualys_vulns/'

        # Get the selected vulnerability type from the dropdown menu
        vulnerability_type = request.POST.get('vulnerability_type')

        # Check if the selected vulnerability type is Qualys or Defender and set the filename accordingly
        if vulnerability_type == 'Qualys':
            new_filename = 'QualysVulnerabilities.xlsx'
            script_path = '/var/csirt/source/CVE-WEB/scripts/updatequalys.sh'
        elif vulnerability_type == 'Defender':
            new_filename = 'DefenderVulnerabilities.xlsx'
            script_path = '/var/csirt/source/CVE-WEB/scripts/updatedefender.sh'
        else:
            # Return an error message if the selected vulnerability type is invalid
            context = {'filename': '', 'upload_result': 'error', 'output': '', 'error': 'Invalid request'}
            return render(request, 'qualys_upload.html', context)

        file_path = os.path.join(upload_path, new_filename)

        # Remove the existing "Vulnerabilities.xlsx" file if it exists
        existing_file_path = os.path.join(upload_path, new_filename)
        if os.path.isfile(existing_file_path):
            os.remove(existing_file_path)

        # Save the uploaded file with the appropriate filename
        with open(file_path, 'wb') as f:
            for chunk in file.chunks():
                f.write(chunk)

        # Run the appropriate script based on the selected vulnerability type
        process = subprocess.Popen(['/bin/bash', script_path, file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate()

        # Decode the output and error from bytes to string
        output = output.decode()
        error = error.decode()

        # Render the qualys_upload.html template with the upload result and script output
        context = {'filename': new_filename, 'upload_result': 'success', 'output': output, 'error': error}
        return render(request, 'qualys_upload.html', context)

    return render(request, 'qualys_upload.html')

@login_required
@user_passes_test(is_member_of_group('CSIRT'))
def AttackSurfaceDomains(request):
    okdomains = OKDomains.objects.all()
    context = {'okdomains': okdomains}
    return render(request,'attack_surface_domains.html', context)

def InsertOKDomain(request):
    blacklist = ['powerapps']
    if request.method == 'POST':
        form = OKDomainsForm(request.POST)
        if form.is_valid():
            # Extract form data and create a new OKDomains object
            domain = form.cleaned_data['domain']

            # Check if domain is in blacklist 
            for entry in blacklist:
                if entry in str(domain):
                    context = {'uploadmessage': 'Error: Domain is blacklisted'}
                    return render(request, 'domains_upload.html', context)

            okdomains, created = OKDomains.objects.get_or_create(domain=domain)

            if created:
                # New domain, set all fields from form data
                okdomains.registrar = form.cleaned_data['registrar']
                okdomains.server = form.cleaned_data['server']
                okdomains.system = form.cleaned_data['system']
                okdomains.system_owner = form.cleaned_data['system_owner']
                okdomains.comments = form.cleaned_data['comments']
                okdomains.changes_since_last = "Initial upload"
            else:
                # Existing domain, update fields only if not empty
                if form.cleaned_data['registrar']:
                    okdomains.registrar = form.cleaned_data['registrar']
                if form.cleaned_data['server']:
                    okdomains.server = form.cleaned_data['server']
                if form.cleaned_data['system']:
                    okdomains.system = form.cleaned_data['system']
                if form.cleaned_data['system_owner']:
                    okdomains.system_owner = form.cleaned_data['system_owner']
                if form.cleaned_data['comments']:
                    okdomains.comments = form.cleaned_data['comments']
                okdomains.changes_since_last = "Updated from upload"

            okdomains.save()
            context = {'uploadmessage': 'Upload completed'}
            return render(request, 'domains_upload.html', context)

        elif request.method == 'POST' and request.FILES:
            # Read CSV file and update database
            try:
                file = request.FILES['file']
                decoded_file = file.read().decode('ISO-8859-1').splitlines()
                reader = csv.DictReader(decoded_file)

                domains = []
                for row in reader:
                    domain = row.get('domain')
                    domains.append(domain)

                # Get all existing domains from database
                existing_domains = OKDomains.objects.filter(domain__in=domains)

                # Update the existing domains
                for existing_domain in existing_domains:
                    # Update fields only if not empty
                    if row.get('registrar'):
                        existing_domain.registrar = row.get('registrar')
                    if row.get('server'):
                        existing_domain.server = row.get('server')
                    if row.get('system'):
                        existing_domain.system = row.get('system')
                    if row.get('system_owner'):
                        existing_domain.system_owner = row.get('system_owner')
                    if row.get('comments'):
                        existing_domain.comments = row.get('comments')
                    existing_domain.changes_since_last = "Updated from upload"
                    existing_domain.save()

                existing_db_domains = []
                for entry in existing_domains.values():
                    print(entry["domain"])
                reader = csv.DictReader(decoded_file)
                for row in reader:
                    domain = row.get('domain')
                    if domain not in existing_domains.values():

                        for entry in blacklist:
                            if str(domain) not in entry:
                                new_domain = OKDomains(
                                    domain=domain,
                                    registrar=row.get('registrar'),
                                    server=row.get('server'),
                                    system=row.get('system'),
                                    system_owner=row.get('system_owner'),
                                    comments=row.get('comments'),
                                    changes_since_last="Added from upload"
                                )
                                new_domain.save()

                context = {'uploadmessage': 'Upload completed'}
                return render(request, 'domains_upload.html', context)

            except Exception as e:
                context = {'uploadmessage': 'Error during file upload: {}'.format(e)}
                return render(request, 'domains_upload.html', context)
    else:
        form = OKDomainsForm()
        context = {'form': form}
        return render(request, 'domains_upload.html', context)